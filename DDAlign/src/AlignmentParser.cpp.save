// $Id: Geant4Setup.cpp 578 2013-05-17 22:33:09Z markus.frank $
//====================================================================
//  AIDA Detector description implementation for LCD
//--------------------------------------------------------------------
//
//  Author     : M.Frank
//
//====================================================================
// Framework include files
#include "DD4hep/LCDD.h"
#include "DD4hep/Printout.h"
#include "XML/Conversions.h"
#include "XML/XMLElements.h"
#include "XML/DocumentHandler.h"
#include "DD4hep/MatrixHelpers.h"
#include "DD4hep/DetectorTools.h"
#include "DD4hep/DetFactoryHelper.h"
#include "DD4hep/DetectorAlignment.h"

#include "DDAlign/AlignmentTags.h"
#include "TGeoManager.h"
#include "Math/Rotation3D.h"
#include "Math/Translation3D.h"

using namespace std;
using namespace DD4hep;
typedef DD4hep::Geometry::DetectorAlignment DetectorAlignment;
typedef DD4hep::Geometry::DetectorTools   DetectorTools;
typedef DD4hep::Geometry::RotationZYX     RotationZYX;
typedef DD4hep::Geometry::Rotation3D      Rotation3D;
typedef DD4hep::Geometry::Position        Position;
typedef DD4hep::Geometry::Transform3D     Transform3D;
typedef ROOT::Math::Translation3D         Translation3D;
typedef DD4hep::Geometry::DetElement      DetElement;
typedef DD4hep::Geometry::Alignment       Alignment;

typedef DD4hep::Geometry::LCDD lcdd_t;

namespace DD4hep  {


  /** @class AlignmentCache AlignmentCache.h AlignmentCache.h
   *
   */
  class AlignmentCache  {
  protected:
    typedef std::map<unsigned int, TGeoPhysicalNode*> Cache;
    /// The subdetector specific map of alignments caches
    Cache m_cache;
    std::string m_sdPath;
    size_t      m_sdPathLen;
  public:
    /// Default constructor
    AlignmentCache(const std::string& sdPath);
    /// Default destructor
    virtual ~AlignmentCache();
    /// Add a new entry to the cache. The key is the placement path
    bool insert(Alignment alignment);
    /// Retrieve an alignment entry by its lacement path
    Alignment get(const std::string& path) const;
  };

  /// one-at-time hash function
  static unsigned int hash32(const char* key) {
    unsigned int hash = 0;
    const char* k = key;
    for (; *k; k++) {
      hash += *k; 
      hash += (hash << 10); 
      hash ^= (hash >> 6);
    }
    hash += (hash << 3); 
    hash ^= (hash >> 11); hash += (hash << 15);
    return hash;
  }

  /// Default constructor
  AlignmentCache::AlignmentCache(const std::string& sdPath)
    : m_sdPath(sdPath), m_sdPathLen(sdPath.length())
  {
  }

  /// Default destructor
  AlignmentCache::~AlignmentCache()   {
    m_cache.clear();
  }

  /// Add a new entry to the cache. The key is the placement path
  bool AlignmentCache::insert(Alignment alignment)  {
    TGeoPhysicalNode* pn = alignment.ptr();
    unsigned int index = hash32(pn->GetName()+m_sdPathLen);
    Cache::const_iterator i = m_cache.find(index);
    if ( i == m_cache.end() )   {
      m_cache[index] = pn;
      return true;
    }
    return false;
  }

  /// Retrieve an alignment entry by its lacement path
  Alignment AlignmentCache::get(const std::string& path) const   {
    unsigned int index = hash32(path.c_str()+m_sdPathLen);
    Cache::const_iterator i = m_cache.find(index);
    return Alignment(i == m_cache.end() ? 0 : (*i).second);
  }

  AlignmentCache* subdetectorAlignments(const std::string& name)   {
    typedef map<string,AlignmentCache*> SubdetectorAlignments;
    SubdetectorAlignments c;
    SubdetectorAlignments::const_iterator i = c.find(name);
    if ( i == c.end() )   {
      AlignmentCache* ptr = new AlignmentCache(name);
      c.insert(make_pair(name,ptr));
      return ptr;
    }
    return (*i).second;
  }

  namespace   {
    class alignment;
    class subdetector;
    class detelement;
    class include_file;
    class volume;
    class rotation;
    class position;
    class pivot;
    class transform3d;
  }
  template <> void Converter<alignment>::operator()(xml_h seq)  const;
  
  namespace {
    using namespace Geometry;
#if 0
    void alignment_reset_dbg(const string& path, const Alignment& a)   {      
      TGeoPhysicalNode* n = a.ptr();
      cout << " +++++++++++++++++++++++++++++++ " << path << endl;
      cout << "      +++++ Misaligned physical node: " << endl;
      n->Print();
      string np;
      if ( n->IsAligned() ) {
	for (Int_t i=0; i<=n->GetLevel(); i++) {
	  TGeoMatrix* mm = n->GetNode(i)->GetMatrix();
	  np += "/";
	  np += n->GetNode(i)->GetName();
	  if ( mm->IsIdentity() ) continue;
	  if ( i == 0 ) continue;

	  TGeoHMatrix* glob = n->GetMatrix(i-1);
	  NodeMap::const_iterator j=original_matrices.find(np);
	  if ( j != original_matrices.end() && i!=n->GetLevel() )   {
	    cout << "      +++++ Patch Level: " << i << np << endl;
	    *mm = *((*j).second);
	  }
	  else  {
	    if ( i==n->GetLevel() ) {
	      cout << "      +++++ Level: " << i << np << " --- Original matrix: " << endl;
	      n->GetOriginalMatrix()->Print();
	      cout << "      +++++ Level: " << i << np << " --- Local matrix: " << endl;
	      mm->Print();
	      TGeoHMatrix* hm = dynamic_cast<TGeoHMatrix*>(mm);
	      hm->SetTranslation(n->GetOriginalMatrix()->GetTranslation());
	      hm->SetRotation(n->GetOriginalMatrix()->GetRotationMatrix());
	      cout << "      +++++ Level: " << i << np << " --- New local matrix" << endl;
	      mm->Print();
	    }
	    else	      {
	      cout << "      +++++ Level: " << i << np << " --- Keep matrix " << endl;
	      mm->Print();
	    }
	  }
	  cout << "      +++++ Level: " << i << np << " --- Global matrix: " << endl;
	  glob->Print();
	  *glob *= *mm;
	  cout << "      +++++ Level: " << i << np << " --- New global matrix: " << endl;
	  glob->Print();
	}
      }
      cout << "\n\n\n      +++++ physical node (full): " << np <<  endl;
      n->Print();
      cout << "      +++++ physical node (global): " << np <<  endl;
      n->GetMatrix()->Print();
    }
#endif

    void alignment_reset(AlignmentCache* cache, const string& path, const Alignment& a)   {      
      TGeoPhysicalNode* pn = a.ptr();
      string np;
      if ( pn->IsAligned() )   {
	for (Int_t i=0, nLvl=pn->GetLevel(); i<=nLvl; i++) {
	  TGeoNode* node = pn->GetNode(i);
	  TGeoMatrix* mm = node->GetMatrix();  // Node's relative matrix
	  np += string("/")+node->GetName();
	  if ( !mm->IsIdentity() && i > 0 )  {    // Ignore the 'world', is identity anyhow
	    TGeoHMatrix* glob = pn->GetMatrix(i-1);
	    Alignment a = cache->get(np);
	    if ( a.isValid() && i!=nLvl )   {
	      *mm = *(a->GetOriginalMatrix());
	    }
	    else if ( i==nLvl ) {
	      TGeoHMatrix* hm = dynamic_cast<TGeoHMatrix*>(mm);
	      TGeoMatrix*  org = pn->GetOriginalMatrix();
	      hm->SetTranslation(org->GetTranslation());
	      hm->SetRotation(org->GetRotationMatrix());
	    }
	    *glob *= *mm;
	  }
	}
      }
    }
  }



  /** Convert rotation objects
   *
   *    <rotation x="0.5" y="0"  z="0"/>     
   */
  template <> void Converter<rotation>::operator()(xml_h e) const {
    xml_comp_t r(e);
    RotationZYX* v = (RotationZYX*)param;
    v->SetComponents(r.z(), r.y(), r.x());
    printout(INFO,"Alignment<rotation>",
	     "  Rotation:   x=%9.3f y=%9.3f   z=%9.3f  phi=%7.4f psi=%7.4f theta=%7.4f",
	     r.x(), r.y(), r.z(), v->Phi(), v->Psi(), v->Theta());
  }

  /** Convert position objects
   *
   *    <position x="0.5" y="0"  z="0"/>     
   */
  template <> void Converter<position>::operator()(xml_h e) const {
    xml_comp_t p(e);
    Position* v = (Position*)param;
    v->SetXYZ(p.x(), p.y(), p.z());
    printout(INFO,"Alignment<position>","  Position:   x=%9.3f y=%9.3f   z=%9.3f",
	     v->X(), v->Y(), v->Z());
  }

  /** Convert pivot objects
   *
   *    <pivot x="0.5" y="0"  z="0"/>     
   */
  template <> void Converter<pivot>::operator()(xml_h e) const {
    xml_comp_t p(e);
    double x,y,z;
    Translation3D* v = (Translation3D*)param;
    v->SetXYZ(x=p.x(), y=p.y(), z=p.z());
    printout(INFO,"Alignment<pivot>","     Pivot:      x=%9.3f y=%9.3f   z=%9.3f",x,y,z);
  }

  /** Convert transform3d objects
   *
   *     A generic alignment transformation is defined by
   *     - a translation in 3D space identified in XML as a
   *	   <position/> element
   *	 - a rotation in 3D space around a pivot point specified in XML by
   *	   2 elements: the <rotation/> and the <pivot/> element.
   *	 The specification of any of the elements is optional:
   *     - The absence of a translation implies the origine (0,0,0)
   *     - The absence of a pivot point implies the origine (0,0,0)
   *	 - The absence of a rotation implies the identity rotation.
   *	   Any supplied pivot point in this case is ignored.
   *
   *	<xx>
   *	  <position x="0" y="0"  z="0.0001*mm"/>
   *	  <rotation x="0" y="0"  z="0"/>     
   *	  <pivot    x="0" y="0"    z="100"/>     
   *	</xx>
   *
   */
  template <> void Converter<transform3d>::operator()(xml_h e) const {
    typedef pair<bool,Transform3D> Data;
    Position pos;
    RotationZYX rot;
    Translation3D piv;
    xml_h child_rot, child_pos, child_piv;
    Data* tr = (Data*)param;
    
    if ( (child_pos=e.child(_U(position),false)) )
      Converter<position>(lcdd,&pos)(child_pos);
    if ( (child_rot=e.child(_U(rotation),false)) )   {
      Converter<rotation>(lcdd,&rot)(child_rot);
      if ( (child_piv=e.child(_U(pivot),false)) )
	Converter<pivot>(lcdd,&piv)(child_piv);
    }
    tr->first = true;
    if ( child_rot && child_pos && child_piv )
      tr->second = Transform3D(Translation3D(pos)*piv*rot*(piv.Inverse()));
    else if ( child_rot && child_pos )
      tr->second = Transform3D(rot,pos);
    else if ( child_rot && child_piv )
      tr->second = Transform3D(piv*rot*(piv.Inverse()));
    else if ( child_rot )
      tr->second = Transform3D(rot);
    else if ( child_pos )
      tr->second = Transform3D(pos);
    else   {
      tr->first  = false;
    }
  }

  /** Convert volume objects
   *
   *	<volume subpath="layer4_0">
   *	  <position x="0"   y="0"  z="0"/>
   *	  <rotation x="0.5" y="0.1"  z="0.2"/>     
   *	  <pivot    x="0" y="0"    z="100"/>
   *      <volume>
   *         ...
   *      </volume>
   *	</volume>
   */
  template <> void Converter<volume>::operator()(xml_h e) const {
    pair<bool,Transform3D> trafo;
    pair<DetElement,string>* elt = (pair<DetElement,string>*)param;
    string subpath = e.attr<string>(_U(path));
    bool   reset   = e.hasAttr(_U(reset)) ? e.attr<bool>(_U(reset)) : false;

    printout(INFO,"Alignment<volume>","    path:%s / %s reset:%s",
	     elt->first.path().c_str(),subpath.c_str(), reset ? "YES" : "NO");
    Converter<transform3d>(lcdd,&trafo)(e);

    pair<DetElement,string> vol_param(elt->first,subpath);
    xml_coll_t(e,_U(volume)).for_each(Converter<volume>(lcdd,&vol_param));
  }

  /** Convert detelement objects
   *
   *    Function entry expects as a parameter a valid DetElement handle
   *    pointing to the subdetector, which detector elements should be 
   *    realigned.
   *
   *    <detelement path="/world/TPC/TPC_SideA/TPC_SideA_sector02">
   *      <position x="0"   y="0"  z="0"/>
   *      <rotation x="0.5" y="0"  z="0"/>     
   *	  <pivot    x="0" y="0"    z="100"/>     
   *    </detelement>
   */
  template <> void Converter<detelement>::operator()(xml_h e) const {
    xml_comp_t node(e);
    string path = node.attr<string>(_U(path));
    bool   check = node.hasAttr(_U(check_overlaps));
    bool   overlap = node.hasAttr(_U(overlap));
    bool   reset   = node.hasAttr(_U(reset)) ? node.attr<bool>(_U(reset)) : false;
    DetElement det(param ? (TNamed*)param : 0);
    DetElement elt  = DetectorTools::findElement(det,path);

    if ( !elt.isValid() )   {
      string err = "DD4hep: DetElement "+det.path()+" has no child:"+path+" [No such child]";
      throw runtime_error(err);
    }

    string placementPath = elt.isValid() ? elt.placementPath() : string("-----");
    printout(INFO,"Alignment<detelement>","path:%s [%s] placement:%s reset:%s",
	     path.c_str(), 
	     elt.isValid() ? elt.path().c_str() : "-----",
	     placementPath.c_str(),
	     reset ? "YES" : "NO");

    if ( reset && elt.alignment().isValid() )   {
      alignment_reset(det, placementPath, elt.alignment());
    }

    int sc = 0;
    pair<bool,Transform3D> trafo;
    Converter<transform3d>(lcdd,&trafo)(e);
    if ( trafo.first )  {
      DetectorAlignment alignment(elt);
      // Need to care about optional arguments 'check_overlaps' and 'overlap'
      if ( check && overlap )  {
	bool   check_overlaps = node.attr<bool>(_U(check_overlaps));
	double overlap = node.attr<double>(_U(overlap));
	sc = alignment.align(trafo.second, check_overlaps, overlap);
      }
      else if ( check ) {
	bool check_overlaps = node.attr<bool>(_U(check_overlaps));
	sc = alignment.align(trafo.second, check_overlaps);
      }
      else  {
	sc = alignment.align(trafo.second);
      }
      if ( !subDetectorAlignment(elt)->insert(alignment) )  {
	// Error
      }
    }
    pair<DetElement,string> vol_param(elt,"");
    xml_coll_t(node,_U(volume)).for_each(Converter<volume>(lcdd,&vol_param));
  }

  /** Convert subdetector objects
   *
   *   <subdetector name="TPC">
   *    <detelement path="/world/TPC/TPC_SideA/TPC_SideA_sector02">
   *      ...
   *    </detelement>
   *    ...
   *    <include ref="file-name"/>
   *    ...
   *   </subdetector>
   */
  template <> void Converter<subdetector>::operator()(xml_h e) const {
    xml_comp_t sd(e);
    string path  = sd.nameStr();
    bool   reset = sd.hasAttr(_U(reset)) ? sd.attr<bool>(_U(reset)) : false;
    printout(INFO,"Alignment<subdetector>","name:%s reset:%s",
	     path.c_str(), reset ? "YES" : "NO");
    DetElement elt = DetectorTools::findElement(lcdd.world(),path);
    if ( !elt.isValid() )   {
      throw runtime_error("DD4hep: The subdetector "+path+" is not present [Invalid Handle]");
    }
    string placementPath = elt.placementPath();
    if ( reset && elt.alignment().isValid() )   {
      alignment_reset(elt, placementPath, elt.alignment());
    }
    xml_coll_t(sd,_U(detelement)).for_each(Converter<detelement>(lcdd,&elt));
    xml_coll_t(sd,_U(include)).for_each(Converter<include_file>(lcdd,&elt));
  }

  /** Convert detelement_inlclude objects
   *
   *    <detelement path="/world/TPC/TPC_SideA/TPC_SideA_sector02">
   *      <position x="0"   y="0"  z="0"/>
   *      <rotation x="0.5" y="0"  z="0"/>     
   *    </detelement>
   */
  template <> void Converter<include_file>::operator()(xml_h element) const {
    xml_h node = XML::DocumentHandler().load(element, element.attr_value(_U(ref))).root();
    string tag = node.tag();
    if ( tag == "alignment" )  {
      Converter<alignment>(lcdd,param)(node);
    }
    else if ( tag == "subdetector" )  {
      Converter<subdetector>(lcdd,param)(node);
    }
    else if ( tag == "detelement" )    {
      Converter<detelement>(lcdd,0)(node);
    }
    else if ( tag == "subdetectors" )    {
      xml_coll_t(node,_U(subdetector)).for_each(Converter<subdetector>(lcdd,param));
    }
    else if ( tag == "detelements" )    {
      xml_coll_t(node,_U(detelement)).for_each(Converter<detelement>(lcdd,0));
    }
  }

  template <> void Converter<alignment>::operator()(xml_h seq)  const  {
    xml_elt_t compact(seq);
    xml_coll_t(compact,_U(subdetectors)).for_each(_U(subdetector),Converter<subdetector>(lcdd,param));
    xml_coll_t(compact,_U(include)).for_each(Converter<include_file>(lcdd,param));
  }
}

static long setup_Alignment(lcdd_t& lcdd, const xml_h& e) {
  TGeoManager* mgr = gGeoManager;
  if ( 1 || e.hasAttr("print") )   {
    TObjArray* pn = mgr->GetListOfPhysicalNodes();
    TIter next(pn);
    int count = 0;
    typedef TGeoPhysicalNode PN;
    for (PN *p=(PN*)next(); p; p=(PN*)next(), ++count) {
      //p->Print();
    }
    printout(INFO,"Alignment","Found %d physical nodes registered to the geometyry manager",count);
  }
#if 0
  if ( original_matrices.size() > 0 )  {
    const NodeMap& nm = original_matrices;
    for(NodeMap::const_iterator i=nm.begin(); i!=nm.end();++i)  {
      cout << "Nodemap: " << (*i).first << endl;
      //(*i).second->Print();
    }
    //mgr->UnlockGeometry();
    //mgr->ClearPhysicalNodes(kTRUE);
    //mgr->RefreshPhysicalNodes();
    //return 1;
  }
#endif
  (Converter<alignment>(lcdd))(e);
  printout(INFO,"Alignment","Refreshing physical nodes....");
  mgr->GetCurrentNavigator()->ResetAll();
  mgr->GetCurrentNavigator()->BuildCache();
  mgr->RefreshPhysicalNodes();
  return 1;
}
DECLARE_XML_DOC_READER(alignment,setup_Alignment)
